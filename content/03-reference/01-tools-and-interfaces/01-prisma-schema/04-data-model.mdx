---
title: 'Data model'
metaTitle: 'Data model (Reference)'
metaDescription: 'Learn about the concepts for building your data model with Prisma: Models, scalar types, enums, attributes, functions, IDs, default values and more.'
tocDepth: 2
---

## Overview

The data model definition defines your _application models_ (also called _Prisma models_). These models represent the _entities of your application domain_ and map to the _tables_ in your database.

Models are the foundation for all available queries in the [Prisma Client API](../prisma-client/api). When used with TypeScript, Prisma Client provides generated type definitions for your models and any [variations](../prisma-client/advanced-usage-of-generated-types) of them to make database access entirely type safe.

### Application domain examples

A few examples for application domains and "typical" models are:

- In a **blogging** application you probably have models like `Blog`, `Author`, `Article` and `Comment`.
- In an **e-commerce** application you probably have models like `Customer`, `Order`, `Item` and `Invoice`.
- In a **social media** application you probably have models like `User`, `Post`, `Photo` and `Message`.

### Technical purpose of Prisma models

On a _technical_ level, models serve two main purposes:

- They represent the tables in the underlying database.
- They are the foundation for the available queries in the generated [Prisma Client API](../prisma-client/api).

### Data modeling primitives

You can create your data model using the following primitives:

- `model`: Defines a [Prisma model](models)
- `enum`: Defines an [enum](#enums) (only available if enums are supported natively by your database)

Additionally, you can configure your models with [attributes](#attributes) and [functions](#functions).

## Example

```prisma
datasource postgresql {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  role    Role     @default(USER)
  posts   Post[]
  profile Profile?
}

model Profile {
  id      Int     @id @default(autoincrement())
  bio     String
  user    User    @relation(fields: [userId], references: [id])
  userId  Int
}

model Post {
  id         Int         @id @default(autoincrement())
  createdAt  DateTime    @default(now())
  title      String
  published  Boolean     @default(false)
  author     User        @relation(fields: [authorId], references: [id])
  authorId   Int
  categories Category[]  @relation(references: [id])
}

model Category {
  id    Int     @id @default(autoincrement())
  name  String
  posts Post[]  @relation(references: [id])
}

enum Role {
  USER
  ADMIN
}
```

## Introspection vs Prisma Migrate

Depending on the use case, the data model is typically created in either of two ways:

- **Manually written**: You can write your data model manually and map it to your database using [Prisma Migrate](../prisma-migrate) (experimental). In this case, the data model is the single source of truth for the models of your application.
- **Generated from introspection**: When you have an existing database or prefer migrating your database schema with SQL, you generate the data model by [introspecting](../introspection) your database. In this case, the database schema is the single source of truth for the models of your application.

> **Note**: Since Prisma Migrate is currently in an experimental state, the officially recommended way for using Prisma is the introspection-based approach.

## Models

Models represent the entities of your application domain. They are defined using `model` blocks in the data model. In the [example data model](data-model#example), `User`, `Profile`, `Post` and `Category` are models. Here's the `User` model from the example for reference:

```prisma
model User {
  id Int @id @default(autoincrement())
  createdAt DateTime @default(now())
  email String @unique
  name String?
  role Role @default(USER)
  posts Post[]
  profile Profile?
}
```

On a technical level, a model maps to the underlying structures of the data source, e.g.:

- In PostgreSQL, a model maps to a _table_
- In MySQL, a model maps to a _table_
- In SQLite, a model maps to a _table_

> **Note**: In the future there might be connectors for non-relational databases and other data sources. For example, for MongoDB a model would map to a _collection_, for a REST API it would map to a _resource_.

### Model names and table names

Note that naming conventions in databases wildly differ. A common approach for naming tables in databases is to use plural form and [snake_case](https://en.wikipedia.org/wiki/Snake_case) notation, e.g. `users`. When introspecting a database where a table is called `users`, you'll end up with a model looking similar to this:

```prisma
model users {
  id          Int     @id @default(autoincrement())
  first_name  String
  // more fields ...
}
```

In this case, the naming convention of the Prisma schema is violated. However, you can still adhere to the naming convention without renaming the underlying `users` table in the database by using the `@@map` attribute:

```prisma
model User {
  id          Int     @id @default(autoincrement())
  first_name  String
  // more fields ...

  @@map(name: "users")
}
```

With this model definition, Prisma automatically maps the `User` model to the `users` table in the underlying database. Note that you can also map column names to field names using `@map`:

```prisma
model User {
  id          Int     @id @default(autoincrement())
  firstName  String   @map(name: "first_name")
  // more fields ...

  @@map(name: "users")
}
```

`@@map` and `@map` are often used to [configure your Prisma Client API](../prisma-client/configuring-the-prisma-client-api) by decoupling it from the naming of tables and columns in the underlying database.

### Models in Prisma Client

#### Queries (CRUD)

Every model in the data model definition will result in a number of CRUD queries in the generated [Prisma Client API](../prisma-client/api):

- `findMany`
- `findOne`
- `create`
- `update`
- `upsert`
- `delete`
- `updateMany`
- `deleteMany`

The operations are accessible via a generated property on the Prisma Client instance. By default the name of the property is the lowercase form of the model name, e.g. `user` for a `User` model or `post` for a `Post` model.

Here is an example illustrating the use of a `user` property from the Prisma Client API:

```js
const newUser = await prisma.user.create({
  data: {
    name: 'Alice',
  },
})
const allUsers = await prisma.user.findMany()
```

#### Type definitions

Prisma Client not only provides a query API for models, it also generates type definitions that reflect your model structures. These are part of the generated [`@prisma/client`](../prisma-client/generating-prisma-client#the-prismaclient-npm-package) node module in a file called `index.d.ts`.

When using TypeScript, these type definitions ensure that all your database queries are entirely type safe and validated at compile-time (even partial queries using [`select`](../prisma-client/field-selection#select) or [`include`](../prisma-client/field-selection#include)).

Even when using plain JavaScript, the type definitions are still included in the `@prisma/client` node module, enabling features like [IntelliSense](https://code.visualstudio.com/docs/editor/intellisense)/autocompletion in your editor.

> **Note**: The actual types are stored in the `.prisma/client` folder. `@prisma/client/index.d.ts` exports the contents of this folder.

For example, the type definition for the `User` model from above would look as follows:

```ts
export type User = {
  id: number
  email: string
  name: string | null
  role: string
}
```

Note that the relation fields `posts` and `profile` are not included in the type definition by default. However, if you need variations of the `User` type you can still define them using some of [Prisma Client's generated helper types](../prisma-client/generating-prisma-client) (in this case, these helper types would be called `UserGetIncludePayload` and `UserGetSelectPayload`).

### Model requirements

If your model name was generated from introspection and doesn't adhere to this naming convention, you can use the `@@map` attribute to define a valid Prisma model name and map it to the non-allowed model name in your database.

## Fields

The properties of a model are called _fields_. Fields map to _columns_ and consist of several parts:

- [Type](#field-types)
- [Type modifier](#type-modifiers) (optional)
- [Attributes](data-model#attributes) (optional)

Here's an overview of these for the fields from the `User` model [above](models#overview:

| Name        | Type       | Scalar vs Relation | Type modifier | Attributes                            |
| :---------- | :--------- | :----------------- | :------------ | :------------------------------------ |
| `id`        | `Int`      | Scalar             | -             | `@id` and `@default(autoincrement())` |
| `createdAt` | `DateTime` | Scalar             | -             | `@default(now())`                     |
| `email`     | `String`   | Scalar             | -             | `@unique`                             |
| `name`      | `String`   | Scalar             | `?`           | -                                     |
| `role`      | `Role`     | Scalar (enum)      | -             | `@default(USER)`                      |
| `posts`     | `Post`     | Relation (virtual) | `?`           | -                                     |
| `profile`   | `Profile`  | Relation (virtual) | `[]`          | -                                     |

### Field types

#### Scalar fields

The type of a field determines its _structure_. A type falls in either of two categories:

- [Scalar type](data-model#scalar-types) (includes [enums](data-model#enums))
- Model (the field is then called [relation field](relations#relation-fields))

#### Relation fields

### Type modifiers

The type of a field can be modified by appending either of two modifiers:

- `[]`: Make a field a **list**
- `?`: Make a field **optional**

In the main example above, the field `name` on the `User` model is _optional_ and the `posts` relation field is a _list_.

Note that you can not combine the list and optional modifiers on the same field. So, the following would be illegal in Prisma:

```prisma
model User {
  id    Int      @id @default(autincremenent())
  posts Post[]?  // 🚨🚓
}
```

#### Lists

When annotated with the `[]` type modifier, a field becomes a list. This means it can hold multiple elements of the specified type.

> **Note**: Scalar lists (arrays) are only supported in the data model if your database natively supports them. Currently, scalar lists are therefore only supported when using PostgreSQL (since MySQL and SQLite don't natively support scalar lists).

### Optional and require fields

When **not** annotating a field with the `?` type modifier, the field will be _required_ on every record of the model. This has effects on two levels:

- **Database**: Required fields are represented via `NOT NULL` constraints in the underlying database.
- **Prisma Client**: Prisma Client's generated [TypeScript types](#type-definitions) that represent the models in your application code will also define these fields as required to ensure they always carry values at runtime.

## Attributes

Attributes modify the behavior of a [field](models#fields) or block (e.g. [models](models)). There are two ways to add attributes to your data model:

- _Field_ attributes are prefixed with `@`
- _Block_ attributes are prefixed with `@@`

<div style="border-radius:8px;background-color: rgb(246, 248, 250); background-image: url(https://cdn.onlinewebfonts.com/svg/img_285835.png);background-size:30px;background-position: 20px 20px;background-repeat:no-repeat; padding:20px 10px 10px 70px;min-height: 70px">
  See <a>API Reference: Attributes</a>
</div>

### IDs

An ID uniquely identifies individual records of a model.

IDs can be defined as:

- A **single field** using `@id`
- **Multiple fields** (also called composite or compound IDs) using `@@id`.

A model can only have _one_ ID, and that ID can either be a single field or based on multiple fields.

#### Single-field IDs

To determine which field of a model represents the ID, you can annotate it with the `@id` attribute. The `id` field represents the ID of the `User` model:

```prisma
model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  role    Role     @default(USER)
  posts   Post[]
  profile Profile?
}
```

<div style="border-radius:8px;background-color: rgb(246, 248, 250); background-image: url(https://cdn.onlinewebfonts.com/svg/img_285835.png);background-size:30px;background-position: 20px 20px;background-repeat:no-repeat; padding:20px 10px 10px 70px;min-height: 70px">
  See <a>API Reference: @id</a>
</div>

#### Multi-field IDs

To determine which fields of a model represent the multi-field ID, you can include them in the `@@id` attribute that's defined on your model.

<div style="border-radius:8px;background-color: rgb(246, 248, 250); background-image: url(https://cdn.onlinewebfonts.com/svg/img_285835.png);background-size:30px;background-position: 20px 20px;background-repeat:no-repeat; padding:20px 10px 10px 70px;min-height: 70px">
  See <a>API Reference: @@id</a>
</div>

### Unique values

You can add unique attributes to your models to be able to uniquely identify individual records of that model.

Unique attributes can be defined on a **single field** using `@unique` or on **multiple fields** (also called composite or compound unique constraints) using `@@unique`. A model can have any number of unique attributes.

> **Note**: Adding a unique constraint automatically adds a corresponding _unique index_ to the specified column(s).

#### Single-field unique attributes

To add a unique attribute to a field of a model, you can annotate it with the `@unique` attribute.

```prisma
model User {
  email String  @unique // `email` can not be optional because it's the only unique field on the model
  name  String?
}
```

<div style="border-radius:8px;background-color: rgb(246, 248, 250); background-image: url(https://cdn.onlinewebfonts.com/svg/img_285835.png);background-size:30px;background-position: 20px 20px;background-repeat:no-repeat; padding:20px 10px 10px 70px;min-height: 70px">
  See <a>API Reference: @unique</a>
</div>

### Multi-field unique attributes

To add multi-field unique attribue to a model, you have to annotate it with the `@@unique` attribute and provide the list of referenced fields as an argument.

<div style="border-radius:8px;background-color: rgb(246, 248, 250); background-image: url(https://cdn.onlinewebfonts.com/svg/img_285835.png);background-size:30px;background-position: 20px 20px;background-repeat:no-repeat; padding:20px 10px 10px 70px;min-height: 70px">
  See <a>API Reference: @@unique</a>
</div>

### Default values

You can define default values for the fields of your models using the `@default` attribute.

The `@default` attribute takes as argument an _expression_, this can be a static, hardcoded value e.g. `5`, `true`, `"Hello"` or a function, e.g. `now()`, `uuid()`, `cuid()`. Note that there is a special function in the Prisma schema called `dbgenerated()` which is used in [introspection](../introspection) results for default values that can not yet be represented in the Prisma schema.

Default values can be defined on any scalar type but not on relation fields.

#### Static default values

For [scalar types](#scalar-types), you can use any static value that corresponds to the type of a field as a default value:

| Type       | Examples                         |
| :--------- | :------------------------------- |
| `Int`      | `-100`, `0`, `42`                |
| `Float`    | `-100.5`, `0`, `4.2`             |
| `String`   | `"Alice"`, `"Hello World"`, `""` |
| `Boolean`  | `true`, `false`                  |
| `DateTime` | `"2020-03-19T14:21:00+0200"`     |

#### Functions as default values

These are the available functions and the types they're compatible with:

### Indexes

You can define indexes on one or multiple fields of your models via the `@@index` on a model.

<div style="border-radius:8px;background-color: rgb(246, 248, 250); background-image: url(https://cdn.onlinewebfonts.com/svg/img_285835.png);background-size:30px;background-position: 20px 20px;background-repeat:no-repeat; padding:20px 10px 10px 70px;min-height: 70px">
  See <a>API Reference: Indexes</a>
</div>

### Mapping column, table and enum names

You can use the `@map` and `@@map` attributes to map field, model and enum names as well in your Prisma schema to different column and table names in the underlying database schema.

Read more about this on the [Configuring the Prisma Client API](../prisma-client/configuring-the-prisma-client-api) page.

<div style="border-radius:8px;background-color: rgb(246, 248, 250); background-image: url(https://cdn.onlinewebfonts.com/svg/img_285835.png);background-size:30px;background-position: 20px 20px;background-repeat:no-repeat; padding:20px 10px 10px 70px;min-height: 70px">
  See <a>API Reference: @map and @@map</a>
</div>

### Relations

You can learn everything about configuration relations on the [Relations](relations) page in the docs.

## Enums

You can define enums in your data model if they're supported by the [data source](data-sources) you use:

- PostgreSQL: [Supported](https://www.postgresql.org/docs/9.1/datatype-enum.html)
- MySQL: [Supported](https://dev.mysql.com/doc/refman/8.0/en/enum.html)
- SQLite: Not supported

Enums are considered [scalar](#scalar-types) types in the Prisma data model. They're therefore [by default](../prisma-client/field-selection#the-default-selection-set) included as return values in [Prisma Client queries](../prisma-client/crud).

Enums are defined via the `enum` block.

## Functions

The Prisma schema supports a number of functions. These can be used to specify [default values](#default-values) on fields of a model. You can find a reference for all available functions [here](#functions-as-default-values).
