---
title: 'Relations'
metaTitle: ''
metaDescription: ''
---

## Overview

This is an extension of the [Data model]() page which describes how to handle relations between Prisma models in the Prisma schema.

Relations between models are _physically_ represented via _foreign keys_ in the underlying database. A foreign key is only stored on _one_ side of a relation. As opposed to how relations are modeled in SQL, **Prisma always requires explicit relation fields on _both_ sides of the relation to be set on your Prisma models**.

This means that one of these relation fields represents the physical foreign key in the underlying database, the other relation field is a [virtual relation field]() (in the case of [implicit many-to-many relations]()), both relation fields are virtual.

The physical relation field must always be accompanied by a [link field]() on the same model.

## Example

The examples on this page are based on the following schema file:

```prisma
model User {
  id      Int      @id @default(autoincrement())
  posts   Post[]
  profile Profile?
}

model Profile {
  id      Int     @id @default(autoincrement())
  user    User    @relation(fields: [userId], references: [id])
  userId  Int     // scalar relation field (linked in the `@relation` attribute above)
}

model Post {
  id         Int         @id @default(autoincrement())
  author     User        @relation(fields: [authorId], references: [id])
  authorId   Int         // scalar relation field  (linked in the `@relation` attribute above)
  categories Category[]  @relation(references: [id])
}

model Category {
  id     Int     @id @default(autoincrement())
  posts  Post[]  @relation(references: [id]) 
}
```

> **Note**: This schema is the same as the [example data model]() but has all [scalar fields]() removed (except for the required [link fields]()) so you can focus on the relation fields.

## Terminology

### Cardinality

There are three different [cardinalities](<https://en.wikipedia.org/wiki/Cardinality_(data_modeling)>) of relations in Prisma:

- One-to-one (also called 1-1-relation)
- One-to-many (also called 1-n-relation)
- Many-to-many (also called m-n-relation)

In the example above, there are the following relations:

- 1-1: `User` ↔ `Profile`
- 1-n: `User` ↔ `Post`
- m-n: `Post` ↔ `Category`

### Relation fields

Relation [fields]() are fields on a Prisma [model]() that do _not_ have a [scalar type](). Instead, their type is another model.

Every relation must have exactly two relation fieds, one on each model. In case of 1-1 and 1-n relations, an additional _relation scalar field_ is required which gets linked by one of the two relation fields. This relation scalar is the direct representation of the _foreign key_ in the underlying database.

Consider these two models:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  role      Role     @default(USER)
  posts     Post[]
}

model Post {
  id         Int     @id @default(autoincrement())
  title      String
  author     User    @relation(fields: [authorId], references: [id])
  authorId   Int     // relation scalar field (linked in the `@relation` attribute above)
}
```

These models have the following fields:

| Model  | Field      | Type     | Relation field               |
| :----- | :--------- | :------- | :--------------------------- |
| `User` | `id`       | `Int`    | No                           |
|        | `email`    | `String` | No                           |
|        | `role`     | `Role`   | No                           |
|        | `posts`    | `Post[]` | **Yes**                      |
| `Post` | `id`       | `Int`    | No                           |
|        | `title`    | `String` | No                           |
|        | `authorId` | `Int`    | No (_relation scalar field_) |
|        | `author`   | `User`   | **Yes** (_annotated_)        |

Both `posts` and `author` are relation fields because their types are not scalar types but other models.

Also note that the annotated relation field `author` needs to link the scalar relation field `authorId` on the `Post` model inside the `@relation` attribute.

### Implicit vs explicit many-to-many relations

Many-to-many relations can be either implicit or explicit in the Prisma schema.

#### Explicit many-to-many relations

Explicit many-to-many relations define an extra model which represents a _relation table_ (also sometimes called _JOIN_, _link_ or _pivot_ table) in the underlying database:

```prisma
model Post {
  id         Int        @id @default(autoincrement())
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

model CategoriesOnPosts {
  post     Post
  category Category

  @@id([post, category])
}
```

#### Implicit many-to-many relations

Implicit many-to-many relations define relation fields as lists on both sides of the relation:

```prisma
model Post {
  id         Int         @id @default(autoincrement())
  categories Category[]  @relation(references: [id])
}

model Category {
  id    Int     @id @default(autoincrement())
  posts Post[]  @relation(references: [id])
}
```

Note that both relation fields in a many-to-many relation must be annotated with the `@relation` attribute and _reference_ the fields of the other model they're mapping to.

Note that this m-n-relation is still manifested in a relation table in the underlying database. However, this relation table is managed by Prisma which makes the [Prisma Client API]() for many-to-many relations a bit simpler (since you e.g. have one fewer level of nesting inside of [nested writes]()).

If you're not using Prisma Migrate but obtain your data model from [introspection](), you can still make use of implicit many-to-many relations by following Prisma's [conventions for relation tables]().

### Relation tables

A relation table (also sometimes called _JOIN_, _link_ or _pivot_ table) connects two or more other tables and therefore creates a _relation_ between them. Creating relation tables is a common data modeling practice in SQL to represent relationships between different entities.

When using Prisma, you can create relation tables by defining [models]() similar to how you would model them as tables. The main difference is that the fields of the relation table are both relation fields are both [physical relation fields]() that each _reference_ a link field.

Relation tables are also often used to add "meta-information" to a relation. For example, _when_ the relation was created.

Here is an example for a relation table called `CategoriesOnPosts`:

```prisma
model Post {
  id         Int        @id @default(autoincrement())
  title      String
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

model CategoriesOnPosts {
  post        Post     @relation(fields: [postId], references: [id])
  postId      Int
  category    Category @relation(fields: [catgoryId], references: [id])
  catgoryId   Int
  createdAt   DateTime @default(now())

  @@id([postId, categoryId])
}
```

In this example, the `createdAt` field stores additional information about the relation between `Post` and `Category` (i.e. it stores the point in time when "the post was added to the catgegory").

Note that the same rules as for [1-n-relations]() apply (because `Post`↔ `CategoriesOnPosts` and `Category` ↔ `CategoriesOnPosts` are both in fact 1-n-relations):

- The relation field on one side must be [virtual]() (here these are `posts` and `categories`)
- The relation field on the other side must be [physical]() and _reference_ a [link field]()

When you don't need to attach additional information to the relation, you can model m-n-relations as [implicit many-to-many relations](#implicit-many-to-many-relations). If you're not using Prisma Migrate but get your data model from introspection, you can s

### Physical relation fields (foreign key)

Physical relation relation fields are relation fields that are _physically_ backed by a foreign key in the underlying database. **They always require the `@relation attribute which must point to a link field**.

### Link fields

A link field always has a scalar type and is the direct representation of a foreign key in the underlying database. It must be _referenced_ inside the `@relation` attribute of its physical relation field:

```prisma
model User {
  id      Int      @id @default(autoincrement())
  posts   Post[]
  profile Profile?
}

model Profile {
  id      Int     @id @default(autoincrement())
  user    User    @relation(fields: [userId], references: [id])
  userId  Int     // scalar relation field (referenced in the `@relation` attribute above)
}

model Post {
  id         Int         @id @default(autoincrement())
  author     User        @relation(fields: [authorId], references: [id])
  authorId   Int         // scalar relation field (referenced in the `@relation` attribute above)
  categories Category[]
}
```

Note that if the annotated relation field is [required](), its relation scalar field counterpart also must be required. If the annotated relation field is [optional](), the relation scalar field also must be optional.


## The @relation attribute

The `@relation` attribute can only be applied to the [relation fields]() of a Prisma model, not to its [scalar fields]().

It is _always_ required on [physical relation fields]() and _sometimes_ required on [virtual relation fields]().

Here are some cases when the `@relation` attribute is required, e.g. when:

- you need to disambiguate a relation (that's e.g. the case when you have two relations between the same models)
- you define a [self-relation](#self-relations)
  <!-- - you need to determine on which side of the relation a foreign key should be used -->
- you need to control how the relation table is represented in the underlying database (e.g. use a specific name for a relation table)

### Signature

```
@relation(_ name: String?, fields: FieldReference[]?, references: FieldReference[]?)
```

> **Note**: The leading underscore in the signature means that the argument name can be omitted.

| Argument     | Type               | Required                                    | Description                                                                                                             | Example                                               |
| :----------- | :----------------- | :------------------------------------------ | :---------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------- |
| `name`       | `String`           | Sometimes (e.g. to disambiguate a relation) | Defines the name of the relationship. In an m-n-relation, it also determines the name of the underlying relation table. | `"CategoryOnPost"`, `"MyRelation"`                    |
| `fields`     | `FieldReference[]` | On physical relation fields                 | A list of [fields]() of the _current_ model                                                                             | `["authorId"]`, `["authorFirstName, authorLastName"]` |
| `references` | `FieldReference[]` | On physical relation fields                 | A list of [fields]() of the model on _the other side of the relation_                                                   | `["id"]`, `["firstName, lastName"]`                   |

<!-- ### Cases when the @relation attribute is required

TBD -->

## One-to-one relations

One-to-one (1-1) relations refer to relations where at most one record can be connected on both sides of the relation.

### Example

In the example above, there's one 1-1-relation betwen `User` and `Profile`:

```prisma
model User {
  id        Int       @id @default(autoincrement())
  profile   Profile?
}

model Profile {
  id      Int    @id @default(autoincrement())
  user    User   @relation(fields: [userId], references: [id])
  userId  Int    // scalar relation field (referenced in the `@relation` attribute above)
}
```

This 1-1-relation expresses the following:

- "a user can have zero or one profiles" (because the `profile` field is [optional]() on `User`)
- "a profile must always be connected to one user"

In SQL, this is typically modeled as follows:

```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Profile" (
    id SERIAL PRIMARY KEY,
    "userId" INTEGER NOT NULL UNIQUE,
    FOREIGN KEY ("useIdr") REFERENCES "User"(id)
);
```

Notice the `UNIQUE` constraint on the foreign key `userId`. If this `UNIQUE` constrain was missing, the relation would be considered a 1-n relation.

The link field `userId` on `Profile` model in the Prisma schema above maps to the `userId` column in the database.

### Making both sides required in one-to-one relations

When using Prisma, you can "augment" a 1-1-relation and make it required on _both_ sides:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  name      String
  profile   Profile
}

model Profile {
  id      Int    @id @default(autoincrement())
  user    User   @relation(fields: [userId], references: [id])
  userId  Int
}
```

This 1-1-relation now expresses the following:

- "a user must always have one profile" (because the `profile` field is [required]() on `User`)
- "a profile must always be connected to one user"

Making the `profile` field on `User` required does not impact the schema in the underlying database since relational databases are not able to model such a constraint. This constraint is implemented and enforced by Prisma's [query engine]().

> **Note**: One-to-one [self-relations](#self-relations) must not be made required on both sides, at least one side always must be declared optional.

It's important to note that in the case of required 1-1-relations, the only way to create a new record for either `User` or `Profile` is by using [nested writes]():

```ts
const user = await prisma.user.create({
  data: {
    name: "Alice"
    create: {
      profile: {
        bio: "Hello World"
      }
    }
  }
})

// or

const user = await prisma.profile.create({
  data: {
    bio: "I like turtles"
    create: {
      user: {
        name: "Bob"
      }
    }
  }
})
```

If you're using [introspection](), you can make 1-1-relations required by manually adjusting your [Prisma schema]() and making both relation fields required, then you can [re-generate Prisma Client]() which will now make sure that the required 1-1-relation is enforced by the query engine.

### Determining the side of the foreign key

Consider again the above 1-1-relation between `User` and `Profile` where `profile` is optional on `User`:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  name      String
  profile   Profile
}

model Profile {
  id      Int    @id @default(autoincrement())
  user    User   @relation(fields: [userId], references: [id])
  userId  Int
}
```

Because the `Profile` model has a [physical relation field]() (called `user`) and a [link field]() (called `userId`), it represents the foreign key in the underlying database. The `profile` relation field on `User` is [virtual]().

This is what the relation looks like in the database:

![](https://imgur.com/N5wHT6D.png)

However, you can still determine yourself on which side of the relation the foreign key should be stored. To store the foreign key on `User` you need to add the `@relation` attribute to its relation field and add a corresponding link field:

**Both relation fields required but using `@relation` to determine the foreign key**

```prisma
model User {
  id         Int      @id @default(autoincrement())
  profile    Profile  @relation(fields: [profileId], references: [id]) // references `id` of `Profile`
  profileId  Int
}

model Profile {
  id   Int    @id @default(autoincrement())
  user User
}
```

**Both relation fields optional but using `@relation` to determine the foreign key\***

```prisma
model User {
  id        Int       @id @default(autoincrement())
  profile   Profile?  @relation(fields: [profileId], references: [id]) // references `id` of `Profile`
}

model Profile {
  id   Int    @id @default(autoincrement())
  user User?
}
```

In both cases, the foreign key is now defined on the `profile` column of the `User` table:

![](https://imgur.com/NAd72ql.png)

## One-to-many

One-to-many (1-n) relations refer to relations where one record on one side of the relation can be connected to zero or more records on the other side.

### One-to-one vs one-to-many relations

In relational databases, the main difference between a 1-1 and a 1-n-relation is that in a 1-1-relation the foreign key must have a `UNIQUE` constraint defined on it.

### Example

In the example above, there's one 1-n-relation betwen `User` and `Post`:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  posts     Post[]
}

model Post {
  id        Int   @id @default(autoincrement())
  author    User  @relation(fields: [authorId], references: [author])
  authorId  Int
}
```

Notice that the `posts` field on `User` is [virtual](), meaning that it's not manifested in the underlying database schema. On the other side of the relation, the [physical relation field]() `author` and the [link field]() `authorId` represent the foreign key in the underlying database.

This 1-n-relation expresses the following:

- "a user can have zero or more posts"
- "a post must always have an author"

In SQL, this is typically modeled as follows:

```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY,
    "authorId" integer NOT NULL,
    FOREIGN KEY ("authorId") REFERENCES "User"(id)
);
```

Since there's no `UNIQUE` constraint on the `author` column (foreign key), you can create multiple `Post` records that point to the same `User` record therefore creating a one-to-many relationship between the two tables.

### Required vs optional relation fields in one-to-many relations

A 1-n-relation always has one [virtual relation field]() (which must be a [list]()) and a [physical relation field]() that references a [link field](). In the example above, `posts` on the `User` model is virtual, `author` represents a foreign key and `authorId` is a link field.

The relation fields in a relation can take the following forms:

- the physical relation field can be either optional or required
- if the physical relation field is required, the link field must be required
- if the physical relation field is optional, the link field must be optional
- the virtual relation field must be a list and is always required

So, the following variant of the example above would be _allowed_:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  posts     Post[]
}

model Post {
  id        Int    @id @default(autoincrement())
  author    User?  @relation(fields: [authorId], references: [author])
  authorId  Int?
}
```

But this one would be _not allowed_:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  posts     Post[]?  // illegal
}

model Post {
  id        Int    @id @default(autoincrement())
  author    User?  @relation(fields: [authorId], references: [author])
  authorId  Int?

}
```

## Many-to-many

Many-to-many (m-n) relations refer to relations where zero or more records on one side of the relation can be connected to zero or more records on the other side. m-n-relations are typically modelled via [relation tables]() in a relational database. m-n-relations can be either [explicit]() or [implicit]() in the Prisma schema.

### Example

In the example above, there's one _implicit_ m-n-relation betwen `Post` and `Category`:

```prisma
model Post {
  id         Int        @id @default(autoincrement())
  categories Category[] @relation(references: [id])
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[] @relation(references: [id])
}
```

Notice that the `posts` field on `Category` and the `categories` field on `Post` both are [virtual](), meaning that they're not manifested in the underlying database schema. Instead, the implicit many-to-many relation is maintained by Prisma with a [relation table]() that's not reflected in the Prisma schema.

Both fields require the `@relation` attribute to specify the fields they _reference_ on the other model.

As another example, assume `Category` had a [multi-field ID]():

```prisma
model Post {
  id         Int         @id @default(autoincrement())
  categories Category[]  @relation(references: [name, position])
}

model Category {
  name      String
  position  Int
  posts     Post[]  @relation(references: [id])

  @@id([name, position])
}
```

This m-n-relation expresses the following:

- "a post can have zero or more categories"
- "a category can have zero or more posts"

The `@relation` attribute on the `Post` model now references the multi-field ID composed of `name` and `position`.

In SQL, the first of the two implicit m-n-relations maps to the following tables (following Prisma's [conventions for relation tables]()):

```sql
CREATE TABLE "Category" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY
);
-- Relation table + indexes -------------------------------------------------------
CREATE TABLE "_CategoryToPost" (
    "A" integer NOT NULL REFERENCES "Category"(id),
    "B" integer NOT NULL REFERENCES "Post"(id)
);
CREATE UNIQUE INDEX "_CategoryToPost_AB_unique" ON "_CategoryToPost"("A" int4_ops,"B" int4_ops);
CREATE INDEX "_CategoryToPost_B_index" ON "_CategoryToPost"("B" int4_ops);
```

![](https://imgur.com/DQClFIX.png)

An _explicit_ variant of a similar m-n-relation would define an extra model to represent a relation table. In this case, you can also attach additional information to the relation (such as the point in time when it was created):

```prisma
model Post {
  id         Int        @id @default(autoincrement())
  title      String
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

model CategoriesOnPosts {
  post        Post     @relation(fields: [postId], references: [id])
  postId      Int
  category    Category @relation(fields: [catgoryId], references: [id])
  catgoryId   Int
  createdAt   DateTime @default(now())

  @@id([postId, categoryId])
}
```

This would be represented as follows in SQL:

```sql
CREATE TABLE "Category" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY
);
-- Relation table + indexes -------------------------------------------------------
CREATE TABLE "CategoryToPost" (
    "categoryId" integer NOT NULL,
    "postId" integer NOT NULL,
    "createdAt" timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY ("categoryId")  REFERENCES "Category"(id),
    FOREIGN KEY ("postId") REFERENCES "Post"(id)
);
CREATE UNIQUE INDEX "CategoryToPost_category_post_unique" ON "CategoryToPost"("category" int4_ops,"post" int4_ops);
```

![](https://imgur.com/JQ22x60.png)

### Conventions for relation tables in implicit m-n-relations

If you're not using Prisma Migrate but obtain your data model from [introspection](), you can still make use of implicit many-to-many relations by following Prisma's conventions for relation tables. For the folowing example, assume you want to create a relation table to get an implicit many-to-many relation for two models called `Post` and `Category`.

#### Table name

The name of the relation table must be prefixed with an underscore:

- **Valid**: `_CategoryToPost`, `_MyRelation`
- **Invalid**: ``CategoryToPost`,`MyRelation`

#### Columns

A relation table for an implicit-many-to-many relation must have exactly two columns:

- A foreign key column that points to `Category` called `A`
- A foreign key column that points to `Post` called `B`

The columns must be called `A` and `B` where `A` points to the model that comes first in the alphabet and `B` points to the column which comes last in the alphabet.

#### Unique index

There further must be a unique index defined on both foreign key columns:

```sql
CREATE UNIQUE INDEX "_CategoryToPost_AB_unique" ON "_CategoryToPost"("A" int4_ops,"B" int4_ops);
```

#### Example

This the a sample SQL statement that would create the three tables including indexes (in PostgreSQL dialect):

```sql
CREATE TABLE "_CategoryToPost" (
    "A" integer NOT NULL REFERENCES "Category"(id) ,
    "B" integer NOT NULL REFERENCES "Post"(id)
);
CREATE INDEX "_CategoryToPost_B_index" ON "_CategoryToPost"("B" int4_ops);
CREATE TABLE "Category" (
    id integer DEFAULT nextval('"Category_id_seq"'::regclass) PRIMARY KEY
);
CREATE UNIQUE INDEX "Category_pkey" ON "Category"(id int4_ops);
CREATE TABLE "Post" (
    id integer DEFAULT nextval('"Post_id_seq"'::regclass) PRIMARY KEY
);
CREATE UNIQUE INDEX "Post_pkey" ON "Post"(id int4_ops);
```

### Configuring the name of the relation table in implicit many-to-many relations

When using Prisma Migrate, you can configure the name of the relation table that's managed by Prisma using the `@relation` attribute. The only requirement is that it starts with an underscore. For example, if you want the relation table to be called `_MyRelationTable` instead of the default name `_CategoryToPost`, you can specify it as follows:

```prisma
model Post {
  id         Int         @id @default(autoincrement())
  categories Category[]  @relation("MyRelationTable", references: [id])
}

model Category {
  id    Int     @id @default(autoincrement())
  posts Post[]  @relation("MyRelationTable", references: [id])
}
```

## Self-relations

A relation field can also reference its own model, in this case the relation is called a _self-relation_. Self-relations can be of any cardinality, 1-1, 1-n and m-n.

Note that self-relations always require the `@relation` attribute.

### One-to-one self-relations

A one-to-one self-relation looks as follows:

```prisma
model User {
  id       Int      @id @default(autoincrement())
  name     String?
  husband  User      @relation("MarriagePartners", fields: [id], references: [id])
  wife     User?     @relation("MarriagePartners")
}
```

This relation expresses the following:

- "a user has zero or one _husband_ "
- "a user can have zero or one _wife_"

Note that one-to-one self-relations can not be made required on both sides, one field has to be optional.

In this case, the `wife` relation field is [virtual](). The `husband` field on the other hand is a [physical relation field](), this means it is backed by a foreign key in the underlying database. Here, `id` is the [link field]() that's referenced by `husband`.

You can also switch the virtual and physical relation fields:

```prisma
model User {
  id       Int      @id @default(autoincrement())
  name     String?
  husband  User      @relation("MarriagePartners", fields: [id], references: [id])
  wife     User?     @relation("MarriagePartners")
}
```

```prisma
model User {
  id       Int      @id @default(autoincrement())
  name     String?
  husband  User?    @relation("MarriagePartners")
  wife     User     @relation("MarriagePartners", fields: [id], references: [id])
}
```

Now the foreign key is stored on `wife` and `husband` is virtual.

This relation is represented as follows in SQL:

```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY REFERENCES "User"(id),
);
```

### One-to-many self relations

A one-to-many self-relation looks as follows:

```prisma
model User {
  id       Int      @id @default(autoincrement())
  name     String?
  teacher  User     @relation("TeacherStudents", fields: [id], references: [id])
  students User[]   @relation("TeacherStudents")
}
```

This relation expresses the following:

- "a user has zero or one _teachers_ "
- "a user can have zero or more _students_"

Note that you can also require each user to have a teacher by making the `teacher` field [required]().

This relation is represented as follows in SQL:

```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY REFERENCES "User"(id),
);
```

### Many-to-many self relations

A many-to-many self-relation looks as follows:

```prisma
model User {
  id          Int      @id @default(autoincrement())
  name        String?
  followedBy  User[]   @relation("UserFollows", references: [id])
  following   User[]   @relation("UserFollows", references: [id])
}
```

This relation expresses the following:

- "a user can be followed by zero or more users"
- "a user can follow zero or more users"

Note that this n-n-relation is [implicit](). This means Prisma maintains a [relation table]() for it in the underlying database:

```sql
CREATE TABLE "User" (
    id integer DEFAULT nextval('"User_id_seq"'::regclass) PRIMARY KEY,
    name text
);
CREATE TABLE "_UserFollows" (
    "A" integer NOT NULL REFERENCES "User"(id) ON DELETE CASCADE ON UPDATE CASCADE,
    "B" integer NOT NULL REFERENCES "User"(id) ON DELETE CASCADE ON UPDATE CASCADE
);
```

### Defining multiple self-relations on the same model

You can also define multiple self-relations on the same model at once. Taking all relations from the previous sections as example, you could define a `User` model as follows:

```prisma
model User {
  id          Int      @id @default(autoincrement())
  name        String?
  husband     User?    @relation("MarriagePartners")
  wife        User     @relation("MarriagePartners")
  teacher     User?    @relation("TeacherStudents")
  students    User[]   @relation("TeacherStudents")
  followedBy  User[]   @relation("UserFollows")
  following   User[]   @relation("UserFollows")
}
```

## Disambiguating relations

When you define two relations between two the same models, you need to add the `name` argument in the `@relation` attribute to disambiguate them. As an example for why that's needed, consider the following models:

```prisma
model User {
  id           Int     @id @default(autoincrement())
  name         String?
  writtenPosts Post[]
  pinnedPost   Post?
}

model Post {
  id          Int     @id @default(autoincrement())
  title       String?
  author      User    @relation(fields: [authorId], references: [id])
  authorId    Int
  pinnedBy    User?   @relation(fields: [pinnedById], references: [id])
  pinnedById  Int?
}
```

In that case, the relations are ambiguous, there are four different ways to interpet them:

- `User.writtenPosts` ↔ `Post.author` + `Post.authorId`
- `User.writtenPosts` ↔ `Post.pinnedBy` + `Post.pinnedById`
- `User.pinnedPost` ↔ `Post.author` + `Post.authorId`
- `User.pinnedPost` ↔ `Post.pinnedBy` + `Post.pinnedById`

To disambiguate these relations, you need to annotate the relation fields with the `@relation` attribute and provide the `name` argument. You can set any `name` (except for the empty string `""`), but it must be the same on both sides of the relation:

```prisma
model User {
  id           Int     @id @default(autoincrement())
  name         String?
  writtenPosts Post[]  @relation("WrittenPosts")
  pinnedPost   Post?   @relation("PinnedPost")
}

model Post {
  id          Int     @id @default(autoincrement())
  title       String?
  author      User    @relation("WrittenPosts", fields: [authorId], references: [id])
  authorId    Int
  pinnedBy    User?   @relation(name: "PinnedPost", fields: [pinnedById], references: [id])
  pinnedById  Int?
}
```
