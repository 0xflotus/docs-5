---
title: 'Introduction'
metaTitle: ''
metaDescription: ''
---

## Overview

This page gives a high-level overview of **what** Prisma is, **why** you want to use and **how** it works.

## What

Prisma is an [open source]() database toolkit. It mainly consists of the following parts:

- **Prisma schema**: The foundation for each Prisma project that contains your database connection, client generators and a representation of your database schema as a Prisma [data model]().
- **Prisma Client**: An auto-generated and type-safe query builder for Node.js and TypeScript.
- **Prisma Migrate** (experimental): A declarative schema migration system.
- **Prisma Studio** (experimental):  A GUI to view and edit data in your database.

## Why

Working with relational databases is a major bottleneck in application development. Debugging SQL queries or complex ORM objects often consume hours of development time.

Prisma makes it easy for developers to reason about their database queries by providing a clean and type-safe API for submitting database queries which returns _plain old JavaScript objects_. 

### Problems with SQL, ORMs and other database tools

The main problem with the database tools that currently exist in the Node.js and TypeScript ecosystem is that they require a major tradeoff between _productvity_ and _control_.

![](https://imgur.com/juPfyZS.png)

#### Raw SQL: Full control, low productivity

With raw SQL (e.g. using the native [`pg`](https://node-postgres.com/) or [`mysql`](https://github.com/mysqljs/mysql#readme) Node.js database drivers) you have full control over your database operations. However, productivity suffers as sending plain SQL strings to the database is cumbersome and comes with a lot of overhead (manual connection handling, repetetive boilerplate, ...).

Another major issue with this approach is that you don't get any type safety for your query results. Of course, you can type the results manually but this is a huge amount of work and requires major refactorings each time you change your database schema or queries to keep the typings in sync.

Furthermore, submitting SQL queries as plain strings means you don't get any autocompletion in your editors.

#### SQL query builders: High control, medium productivity

A common solution that retains a high level of control and provides better productivity is to use a SQL query builder (e.g. [knex.js]()). These sort of tools provide a programmatic abstraction to construct SQL queries.

The biggest drawback with SQL query builders is that application developers still need to think about their data in terms of SQL. This incurs a cognitive and practical cost of translating relational data into objects. Another issue is that it's too easy to shoot yourself in the foot if you don't know exactly what you're doing in your SQL queries.

#### ORMs: Less control, better productivity

ORMs abstract away from SQL by letting you _define your application models as classes_, these classes are mapped to tables in the database. You can then read and write data by calling methods on the instances of your model classes.

This is way more convenient and comes closer to the mental model developers have when thinking about their data. So, what's the catch?

> ORM represents a quagmire which starts well, gets more complicated as time passes, and before long entraps its users in a commitment that has no clear demarcation point, no clear win conditions, and no clear exit strategy.
>
> [The Vietname of Computer Science, Ted Neward (2006)](http://blogs.tedneward.com/post/the-vietnam-of-computer-science/)

As an application developer, the mental model you have for your data is that of an _object_. The mental model for data in SQL on the other hand are _tables_.

The divide between these two different representations of data is often referred to as the [object-relational impedance mismatch](). The object-relational impedance mismatch also is a major reason why many developers don't like working with traditional ORMs. 

As an example, consider how data is organized and relationships are handled with each apprach:

- **Relational databases**: Data is typically normalized (flat) and uses foreign keys to link across entities. The entities then need to be JOINed to manifest the actual relationships.
- **Object-oriented**: Objects can be deeply nested structures where you can traverse relationships simply by using dot notation.

This alludes to one of the major pitfalls with ORMs: While they make it _seem_ that you can simply traverse relationships using familiar dot notation, under the hood the ORM generates SQL JOINs which are expensive and have the potential to drastically slow down your application (one symptom of this is the [n+1 problem](https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping)).

To conlude: The appeal of ORMs is the premise of abstracting away the relational model and thinking about your data purely in terms of objects. While the premise is great, it's based on the wrong assumption that relational data can easily be mapped to objects which leads to lots of complications and pitfalls.

### Prisma makes developers productive

Prisma's main goal is to make application developers more productive when working with databases. Here are a few examples how Prima achieves this:

- **Thinking in objects** instead of mapping relational data
- **Queries not classes** to avoid complex model objects
- **Single source of truth** for database and application models
- **Healthy constraints** that prevent common pitfalls and antipatterns
- **An abstraction that make the right thing easy** ("pit of success")
- **Type-safe database queries** that can be validated at compile time
- **Less boilerplate** so developers can focus on the important parts of their app
- **Auto-completion in code editors** instead of needing to look up documentation

## How

Prisma offers two main workflows which depend on _how_ you're performing _schema migrations_ (e.g.adding new or altering existing tables):

- **SQL migrations and introspection**
- **Prisma Migrate** (experimental)

As long as Prisma Migrate is in an experimental state, the recommended way for using Prisma is with SQL migrations and introspection.

